#!/usr/bin/env python3
"""
Sphinx Documentation Generator for DDD Framework
Generates HTML documentation from extracted Ansible module data.
"""

import os
import shutil
from pathlib import Path
from typing import Dict, List, Any, Optional
import json
import yaml
from datetime import datetime
from textwrap import dedent

from ddd.extractors.ansible_advanced import AdvancedAnsibleExtractor


class SphinxDocumentationGenerator:
    """
    Generate Sphinx-compatible documentation from extracted module data.
    Following the GREEN phase - minimal implementation that works!
    """
    
    def __init__(self, output_dir: Path = None):
        """Initialize the Sphinx generator."""
        self.output_dir = output_dir or Path("docs/generated")
        self.source_dir = self.output_dir / "source"
        self.build_dir = self.output_dir / "build"
        
    def setup_sphinx_project(self):
        """Create basic Sphinx project structure."""
        # Create directories
        self.source_dir.mkdir(parents=True, exist_ok=True)
        self.build_dir.mkdir(parents=True, exist_ok=True)
        
        # Create conf.py
        conf_content = dedent("""
            # Sphinx configuration file - Generated by DDD
            project = 'Ansible Module Documentation'
            copyright = '2025, DDD Framework'
            author = 'Documentation Driven Development'
            
            extensions = [
                'sphinx.ext.autodoc',
                'sphinx.ext.viewcode',
                'sphinx.ext.napoleon',
            ]
            
            templates_path = ['_templates']
            exclude_patterns = []
            
            html_theme = 'alabaster'
            html_static_path = ['_static']
            
            # Custom settings for DDD
            html_title = 'Ansible Module Maintenance Documentation'
            html_short_title = 'Module Docs'
            html_show_sourcelink = False
        """).strip()
        
        (self.source_dir / "conf.py").write_text(conf_content)
        
        # Create directories for static files and templates
        (self.source_dir / "_static").mkdir(exist_ok=True)
        (self.source_dir / "_templates").mkdir(exist_ok=True)
    
    def generate_index(self, modules: List[str]):
        """Generate index.rst file."""
        index_content = dedent("""
            Ansible Module Maintenance Documentation
            =========================================
            
            **Generated by Documentation Driven Development (DDD) Framework**
            
            This documentation provides comprehensive maintenance information for Ansible modules,
            including:
            
            * AWS IAM permission requirements
            * Error patterns and recovery procedures
            * State management and idempotency
            * Maintenance scenarios and runbooks
            
            .. warning::
               🚨 **HUMAN INPUT NEEDED** 🚨
               
               [HUMAN: Review and add business context for each module]
            
            Module Documentation
            --------------------
            
            .. toctree::
               :maxdepth: 2
               :caption: Modules:
               
        """).strip()
        
        # Add each module to the toctree
        for module in sorted(modules):
            index_content += f"\n   modules/{module}"
        
        index_content += dedent("""
            
            
            Maintenance Quick Reference
            ---------------------------
            
            * :ref:`genindex`
            * :ref:`modindex`
            * :ref:`search`
            
            Coverage Report
            ---------------
            
            .. include:: coverage_report.rst
        """)
        
        (self.source_dir / "index.rst").write_text(index_content)
    
    def generate_module_documentation(self, module_name: str, extracted_data: Dict):
        """Generate RST documentation for a single module."""
        # Create modules directory
        modules_dir = self.source_dir / "modules"
        modules_dir.mkdir(exist_ok=True)
        
        # Build the RST content
        rst_content = self._build_module_rst(module_name, extracted_data)
        
        # Write to file
        module_file = modules_dir / f"{module_name}.rst"
        module_file.write_text(rst_content)
    
    def _build_module_rst(self, module_name: str, data: Dict) -> str:
        """Build RST content for a module."""
        rst = f"{module_name}\n{'=' * len(module_name)}\n\n"
        
        # Module overview from documentation
        if 'documentation' in data:
            doc = data['documentation']
            rst += f"**{doc.get('short_description', 'No description available')}**\n\n"
            
            if 'description' in doc:
                rst += "Description\n-----------\n\n"
                if isinstance(doc['description'], list):
                    for item in doc['description']:
                        rst += f"* {item}\n"
                else:
                    rst += f"{doc['description']}\n"
                rst += "\n"
        
        # AWS IAM Permissions
        if 'permissions' in data and data['permissions']:
            rst += self._build_permissions_section(data['permissions'])
        
        # Error Patterns
        if 'error_patterns' in data and data['error_patterns']:
            rst += self._build_error_patterns_section(data['error_patterns'])
        
        # Parameters
        if 'documentation' in data and 'options' in data['documentation']:
            rst += self._build_parameters_section(data['documentation']['options'])
        
        # Examples
        if 'examples' in data and data['examples']:
            rst += self._build_examples_section(data['examples'])
        
        # Return Values
        if 'returns' in data and data['returns']:
            rst += self._build_returns_section(data['returns'])
        
        # Maintenance Scenarios
        if 'scenarios' in data and data['scenarios']:
            rst += self._build_scenarios_section(data['scenarios'])
        
        # Human input markers
        rst += dedent("""
            
            Maintenance Notes
            -----------------
            
            .. warning::
               🚨 **HUMAN INPUT NEEDED** 🚨
               
               * **Business Context**: [HUMAN: What business problem does this module solve?]
               * **Critical Dependencies**: [HUMAN: What systems depend on this module?]
               * **Known Issues**: [HUMAN: Any version-specific issues or gotchas?]
               * **Rollback Procedure**: [HUMAN: How to rollback if module fails?]
        """)
        
        return rst
    
    def _build_permissions_section(self, permissions: List[str]) -> str:
        """Build AWS IAM permissions section."""
        rst = dedent("""
            AWS IAM Permissions Required
            ----------------------------
            
            The following IAM permissions are required for this module to function:
            
            .. code-block:: json
            
               {
                   "Version": "2012-10-17",
                   "Statement": [
                       {
                           "Effect": "Allow",
                           "Action": [
        """).strip() + "\n"
        
        # Add each permission
        for i, perm in enumerate(sorted(permissions)):
            comma = "," if i < len(permissions) - 1 else ""
            rst += f'                       "{perm}"{comma}\n'
        
        rst += dedent("""
                           ],
                           "Resource": "*"
                       }
                   ]
               }
            
            .. note::
               These permissions were automatically extracted from boto3 API calls in the module code.
               Review and restrict Resource ARNs as appropriate for your environment.
            
        """)
        
        return rst
    
    def _build_error_patterns_section(self, errors: List) -> str:
        """Build error patterns section."""
        rst = "Common Error Patterns\n---------------------\n\n"
        
        for error in errors:
            # Handle both dict and ErrorPattern objects
            if hasattr(error, 'message'):
                # ErrorPattern object
                rst += f"**{error.message}**\n\n"
                if error.condition:
                    rst += f"* **Condition**: ``{error.condition}``\n"
                rst += f"* **Recovery**: {error.recovery_hint}\n"
                if error.error_type:
                    rst += f"* **Type**: {error.error_type}\n"
            else:
                # Dictionary
                rst += f"**{error['message']}**\n\n"
                if error.get('condition'):
                    rst += f"* **Condition**: ``{error['condition']}``\n"
                rst += f"* **Recovery**: {error['recovery_hint']}\n"
                if error.get('error_type'):
                    rst += f"* **Type**: {error['error_type']}\n"
            rst += "\n"
        
        return rst
    
    def _build_parameters_section(self, options: Dict) -> str:
        """Build parameters section."""
        rst = "Parameters\n----------\n\n"
        
        for param_name, param_info in options.items():
            rst += f"**{param_name}**\n\n"
            
            if isinstance(param_info, dict):
                if 'description' in param_info:
                    rst += f"   {param_info['description']}\n\n"
                
                # Build parameter table
                rst += "   .. list-table::\n"
                rst += "      :widths: 20 80\n\n"
                
                if 'required' in param_info:
                    rst += f"      * - Required\n        - {param_info['required']}\n"
                if 'type' in param_info:
                    rst += f"      * - Type\n        - {param_info['type']}\n"
                if 'default' in param_info:
                    rst += f"      * - Default\n        - {param_info['default']}\n"
                if 'choices' in param_info:
                    choices = ', '.join(str(c) for c in param_info['choices'])
                    rst += f"      * - Choices\n        - {choices}\n"
                
                rst += "\n"
        
        return rst
    
    def _build_examples_section(self, examples: List[Dict]) -> str:
        """Build examples section."""
        rst = "Usage Examples\n--------------\n\n"
        
        for example in examples:
            if 'name' in example:
                rst += f"**{example['name']}**\n\n"
            
            rst += ".. code-block:: yaml\n\n"
            
            # Format as YAML
            yaml_example = {
                'name': example.get('name', 'Example task'),
                example.get('module', 'module'): example.get('parameters', {})
            }
            
            yaml_str = yaml.dump(yaml_example, default_flow_style=False)
            for line in yaml_str.split('\n'):
                if line:
                    rst += f"   {line}\n"
            
            rst += "\n"
        
        return rst
    
    def _build_returns_section(self, returns: Dict) -> str:
        """Build return values section."""
        rst = "Return Values\n-------------\n\n"
        
        for key, value in returns.items():
            rst += f"**{key}**\n\n"
            
            if isinstance(value, dict):
                if 'description' in value:
                    rst += f"   {value['description']}\n\n"
                
                rst += "   .. list-table::\n"
                rst += "      :widths: 20 80\n\n"
                
                if 'type' in value:
                    rst += f"      * - Type\n        - {value['type']}\n"
                if 'returned' in value:
                    rst += f"      * - Returned\n        - {value['returned']}\n"
                if 'sample' in value:
                    rst += f"      * - Sample\n        - ``{value['sample']}``\n"
            
            rst += "\n"
        
        return rst
    
    def _build_scenarios_section(self, scenarios: List[Dict]) -> str:
        """Build maintenance scenarios section."""
        rst = "Maintenance Scenarios\n--------------------\n\n"
        
        for scenario in scenarios:
            rst += f"**{scenario.get('name', 'Scenario')}**\n\n"
            
            if 'description' in scenario:
                rst += f"{scenario['description']}\n\n"
            
            if 'expected_outcome' in scenario:
                rst += f"* **Expected Outcome**: {scenario['expected_outcome']}\n"
            
            rst += "\n"
        
        return rst
    
    def generate_coverage_report(self, coverage_data: Dict):
        """Generate coverage report RST."""
        rst = dedent("""
            Documentation Coverage Report
            =============================
            
            Generated: {timestamp}
            
            Overall Coverage
            ----------------
            
            .. list-table::
               :widths: 30 20 20 30
               :header-rows: 1
               
               * - Dimension
                 - Coverage
                 - Status
                 - Notes
        """).format(timestamp=datetime.now().isoformat()).strip() + "\n"
        
        # Add coverage data
        if 'dimensions' in coverage_data:
            for dim, score in coverage_data['dimensions'].items():
                status = "✅ Pass" if score >= 0.85 else "❌ Fail"
                percentage = f"{score * 100:.1f}%"
                rst += f"       * - {dim.capitalize()}\n"
                rst += f"         - {percentage}\n"
                rst += f"         - {status}\n"
                rst += f"         - [HUMAN: Add notes]\n"
        
        rst += dedent("""
            
            .. note::
               Coverage measures documentation completeness, not code coverage.
               Target threshold: 85% for MVP.
        """)
        
        (self.source_dir / "coverage_report.rst").write_text(rst)
    
    def build_html(self):
        """Build HTML documentation using Sphinx."""
        # Check if sphinx-build is available
        import subprocess
        
        try:
            # Run sphinx-build
            result = subprocess.run(
                ["sphinx-build", "-b", "html", str(self.source_dir), str(self.build_dir)],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                print(f"✅ HTML documentation generated at: {self.build_dir}")
                return True
            else:
                print(f"❌ Sphinx build failed: {result.stderr}")
                return False
        except FileNotFoundError:
            print("⚠️ Sphinx not installed. Run: pip install sphinx")
            return False
    
    def generate_complete_documentation(self, modules_data: Dict[str, Dict]) -> bool:
        """Generate complete documentation for all modules."""
        # Setup Sphinx project
        self.setup_sphinx_project()
        
        # Generate documentation for each module
        for module_name, data in modules_data.items():
            self.generate_module_documentation(module_name, data)
        
        # Generate index
        self.generate_index(list(modules_data.keys()))
        
        # Generate coverage report if available
        coverage_data = self._calculate_coverage(modules_data)
        self.generate_coverage_report(coverage_data)
        
        # Build HTML
        return self.build_html()
    
    def _calculate_coverage(self, modules_data: Dict[str, Dict]) -> Dict:
        """Calculate documentation coverage from extracted data."""
        dimensions = {}
        
        for module_name, data in modules_data.items():
            # Simple coverage calculation for GREEN phase
            has_docs = 1.0 if 'documentation' in data else 0.0
            has_perms = 1.0 if data.get('permissions') else 0.0
            has_errors = 1.0 if data.get('error_patterns') else 0.0
            has_examples = 1.0 if data.get('examples') else 0.0
            
            dimensions[module_name] = (has_docs + has_perms + has_errors + has_examples) / 4
        
        return {'dimensions': dimensions}